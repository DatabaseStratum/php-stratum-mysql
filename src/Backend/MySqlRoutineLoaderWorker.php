<?php
declare(strict_types=1);

namespace SetBased\Stratum\MySql\Backend;

use SetBased\Exception\RuntimeException;
use SetBased\Helper\InvalidCastException;
use SetBased\Stratum\Backend\RoutineLoaderWorker;
use SetBased\Stratum\Common\Exception\RoutineLoaderException;
use SetBased\Stratum\Common\Helper\SourceFinderHelper;
use SetBased\Stratum\Middle\Exception\ResultException;
use SetBased\Stratum\Middle\Helper\RowSetHelper;
use SetBased\Stratum\Middle\NameMangler\NameMangler;
use SetBased\Stratum\MySql\Exception\MySqlConnectFailedException;
use SetBased\Stratum\MySql\Exception\MySqlDataLayerException;
use SetBased\Stratum\MySql\Exception\MySqlQueryErrorException;
use SetBased\Stratum\MySql\Helper\RoutineLoaderHelper;
use SetBased\Stratum\MySql\Helper\SqlModeHelper;
use SetBased\Stratum\MySql\Helper\StratumMetadataHelper;
use Symfony\Component\Console\Formatter\OutputFormatter;

/**
 * Command for loading stored routines into a MySQL instance from pseudo SQL files.
 */
class MySqlRoutineLoaderWorker extends MySqlWorker implements RoutineLoaderWorker
{
  //--------------------------------------------------------------------------------------------------------------------
  /**
   * The maximum column size in bytes.
   */
  const MAX_COLUMN_SIZE = 65532;

  /**
   * Details of all character sets.
   *
   * @var array[]
   */
  private array $characterSets;

  /**
   * Name of the class that contains all constants.
   *
   * @var string|null
   */
  private ?string $constantClassName;

  /**
   * The default character set under which the stored routine will be loaded and run.
   *
   * @var string
   */
  private string $defaultCharacterSet;

  /**
   * The default collate under which the stored routine will be loaded and run.
   *
   * @var string
   */
  private string $defaultCollate;

  /**
   * An array with source filenames that are not loaded into MySQL.
   *
   * @var string[]
   */
  private array $errorFilenames = [];

  /**
   * Class name for mangling routine and parameter names.
   *
   * @var string|null
   */
  private ?string $nameMangler;

  /**
   * Old metadata of all stored routines. Note: this data comes from information_schema.ROUTINES.
   *
   * @var array
   */
  private array $rdbmsOldMetadata;

  /**
   * A map from placeholders to their actual values.
   *
   * @var array
   */
  private array $replacePairs = [];

  /**
   * Pattern where of the sources files.
   *
   * @var string
   */
  private string $sourcePattern;

  /**
   * All sources with stored routines. Each element is an array with the following keys:
   * <ul>
   * <li> path_name    The path the source file.
   * <li> routine_name The name of the routine (equals the basename of the path).
   * <li> method_name  The name of the method in the data layer for the wrapper method of the stored routine.
   * </ul>
   *
   * @var array[]
   */
  private array $sources = [];

  /**
   * The SQL mode under which the stored routine will be loaded and run.
   *
   * @var string
   */
  private string $sqlMode;

  /**
   * The metadata of all stored routines. Note: this data is stored in the metadata file and is generated by PhpStratum.
   *
   * @var StratumMetadataHelper
   */
  private StratumMetadataHelper $stratumMetaData;

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * @inheritdoc
   *
   * @throws InvalidCastException
   * @throws MySqlConnectFailedException
   * @throws MySqlDataLayerException
   * @throws MySqlQueryErrorException
   * @throws RuntimeException
   * @throws \ReflectionException
   * @throws \RuntimeException
   */
  public function execute(?array $sources = null): int
  {
    $this->io->title('PhpStratum: MySql Loader');

    $metadataFilename          = $this->settings->manString('loader.metadata');
    $this->sourcePattern       = $this->settings->manString('loader.sources');
    $this->sqlMode             = $this->settings->manString('loader.sql_mode');
    $this->defaultCharacterSet = $this->settings->manString('loader.character_set');
    $this->defaultCollate      = $this->settings->manString('loader.collate');
    $this->constantClassName   = $this->settings->optString('constants.class');
    $this->nameMangler         = $this->settings->optString('wrapper.mangler_class');

    $this->connect();

    $this->stratumMetaData = new StratumMetadataHelper($metadataFilename, RoutineLoaderHelper::METADATA_REVISION);
    $this->characterSets   = $this->dl->allCharacterSets();

    if (empty($sources))
    {
      $this->loadAll();
    }
    else
    {
      $this->loadList($sources);
    }

    $this->logOverviewErrors();

    $this->disconnect();

    return ($this->errorFilenames) ? 1 : 0;
  }

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Detects stored routines that would result in duplicate wrapper method name.
   */
  private function detectNameConflicts(): void
  {
    // Get same method names from array
    [$sourcesByPath, $sourcesByMethod] = $this->getDuplicates();

    // Add every not unique method name to myErrorFileNames
    foreach ($sourcesByPath as $source)
    {
      $this->errorFilenames[] = $source['path_name'];
    }

    // Log the sources files with duplicate method names.
    foreach ($sourcesByMethod as $method => $sources)
    {
      $tmp = [];
      foreach ($sources as $source)
      {
        $tmp[] = $source['path_name'];
      }

      $this->io->error(sprintf("The following source files would result wrapper methods with equal name '%s'",
                               $method));
      $this->io->listing($tmp);
    }

    // Remove duplicates from sources.
    foreach ($this->sources as $key => $source)
    {
      if (isset($sourcesByPath[$source['path_name']]))
      {
        unset($this->sources[$key]);
      }
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Drops obsolete stored routines (i.e. stored routines that exits in the current schema but for which we don't have
   * a source file).
   *
   * @throws MySqlQueryErrorException
   */
  private function dropObsoleteRoutines(): void
  {
    // Make a lookup table from routine name to source.
    $lookup = [];
    foreach ($this->sources as $source)
    {
      $lookup[$source['routine_name']] = $source;
    }

    // Drop all routines not longer in sources.
    foreach ($this->rdbmsOldMetadata as $oldRoutine)
    {
      if (!isset($lookup[$oldRoutine['routine_name']]))
      {
        $this->io->logInfo('Dropping %s <dbo>%s</dbo>',
                           strtolower($oldRoutine['routine_type']),
                           $oldRoutine['routine_name']);

        $this->dl->dropRoutine($oldRoutine['routine_type'], $oldRoutine['routine_name']);
      }
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Searches recursively for all source files.
   */
  private function findSourceFiles(): void
  {
    $helper    = new SourceFinderHelper(dirname($this->settings->manString('stratum.config_path')));
    $filenames = $helper->findSources($this->sourcePattern);

    foreach ($filenames as $filename)
    {
      $routineName     = pathinfo($filename, PATHINFO_FILENAME);
      $this->sources[] = ['path_name'    => $filename,
                          'routine_name' => $routineName,
                          'method_name'  => $this->methodName($routineName)];
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Finds all source files that actually exists from a list of file names.
   *
   * @param string[] $sources The list of file names.
   */
  private function findSourceFilesFromList(array $sources): void
  {
    foreach ($sources as $path)
    {
      if (!file_exists($path))
      {
        $this->io->error(sprintf("File not exists: '%s'", $path));
        $this->errorFilenames[] = $path;
      }
      else
      {
        $routineName     = pathinfo($path, PATHINFO_FILENAME);
        $this->sources[] = ['path_name'    => $path,
                            'routine_name' => $routineName,
                            'method_name'  => $this->methodName($routineName)];
      }
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Returns all elements in {@link $sources} with duplicate method names.
   *
   * @return array[]
   */
  private function getDuplicates(): array
  {
    // First pass make lookup table by method_name.
    $lookup = [];
    foreach ($this->sources as $source)
    {
      if (isset($source['method_name']))
      {
        if (!isset($lookup[$source['method_name']]))
        {
          $lookup[$source['method_name']] = [];
        }

        $lookup[$source['method_name']][] = $source;
      }
    }

    // Second pass find duplicate sources.
    $duplicatesSources = [];
    $duplicatesMethods = [];
    foreach ($this->sources as $source)
    {
      if (sizeof($lookup[$source['method_name']])>1)
      {
        $duplicatesSources[$source['path_name']]   = $source;
        $duplicatesMethods[$source['method_name']] = $lookup[$source['method_name']];
      }
    }

    return [$duplicatesSources, $duplicatesMethods];
  }

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Retrieves information about all stored routines in the current schema.
   *
   * @throws MySqlQueryErrorException
   */
  private function getOldStoredRoutinesInfo(): void
  {
    $this->rdbmsOldMetadata = [];

    $routines = $this->dl->allRoutines();
    foreach ($routines as $routine)
    {
      $this->rdbmsOldMetadata[$routine['routine_name']] = $routine;
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Loads all stored routines into MySQL.
   *
   * @throws InvalidCastException
   * @throws MySqlQueryErrorException
   * @throws RuntimeException
   * @throws \ReflectionException
   */
  private function loadAll(): void
  {
    $this->findSourceFiles();
    $this->detectNameConflicts();
    $this->replacePairs();
    $this->getOldStoredRoutinesInfo();

    $this->loadStoredRoutines();

    $this->dropObsoleteRoutines();
    $this->removeObsoleteMetadata();

    $this->io->writeln('');

    $this->writeStoredRoutineMetadata();
  }

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Loads all stored routines in a list into MySQL.
   *
   * @param string[] $sources The list of files to be loaded.
   *
   * @throws InvalidCastException
   * @throws MySqlQueryErrorException
   * @throws \LogicException
   * @throws \ReflectionException
   * @throws \RuntimeException
   */
  private function loadList(array $sources): void
  {
    $this->findSourceFilesFromList($sources);
    $this->detectNameConflicts();
    $this->replacePairs();
    $this->getOldStoredRoutinesInfo();

    $this->loadStoredRoutines();

    $this->writeStoredRoutineMetadata();
  }

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Loads all stored routines.
   *
   * @throws InvalidCastException
   * @throws MySqlQueryErrorException
   * @throws ResultException
   */
  private function loadStoredRoutines(): void
  {
    $this->io->writeln('');

    usort($this->sources, function ($a, $b) {
      return strcmp($a['routine_name'], $b['routine_name']);
    });

    $sqlModeHelper = new SqlModeHelper($this->dl, $this->sqlMode);

    foreach ($this->sources as $filename)
    {
      $routineName = $filename['routine_name'];

      $helper = new RoutineLoaderHelper($this->dl,
                                        $this->io,
                                        $sqlModeHelper,
                                        $filename['path_name'],
                                        $this->stratumMetaData->getMetadata($routineName),
                                        $this->replacePairs,
                                        $this->rdbmsOldMetadata[$routineName] ?? [],
                                        $this->defaultCharacterSet,
                                        $this->defaultCollate);

      try
      {
        $metadata = $helper->loadStoredRoutine();
        $this->stratumMetaData->putMetadata($routineName, $metadata);
      }
      catch (RoutineLoaderException $e)
      {
        $messages = [$e->getMessage(), sprintf("Failed to load file '%s'", $filename['path_name'])];
        $this->io->error($messages);

        $this->errorFilenames[] = $filename['path_name'];
        $this->stratumMetaData->delMetadata($routineName);
      }
      catch (MySqlQueryErrorException $e)
      {
        // Exception is caused by a SQL error. Log the message and the SQL statement with highlighting the error.
        $this->io->error($e->getMessage());
        $this->io->text($e->styledQuery());

        $this->errorFilenames[] = $filename['path_name'];
        $this->stratumMetaData->delMetadata($routineName);
      }
      catch (MySqlDataLayerException $e)
      {
        $this->io->error($e->getMessage());

        $this->errorFilenames[] = $filename['path_name'];
        $this->stratumMetaData->delMetadata($routineName);
      }
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Logs the source files that were not successfully loaded into MySQL.
   */
  private function logOverviewErrors(): void
  {
    if (!empty($this->errorFilenames))
    {
      $this->io->warning('Routines in the files below are not loaded:');
      $this->io->listing($this->errorFilenames);
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Returns the maximum number of characters in a VARCHAR or CHAR.
   *
   * @param string $characterSetName The name of the character set of the column.
   *
   * @return int
   */
  private function maxCharacters(string $characterSetName): ?int
  {
    $key = RowSetHelper::searchInRowSet($this->characterSets, 'character_set_name', $characterSetName);
    if ($key===null) return null;

    $size = $this->characterSets[$key]['maxlen'];

    return (int)floor(self::MAX_COLUMN_SIZE / $size);
  }

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Returns the method name in the wrapper for a stored routine. Returns null when name mangler is not set.
   *
   * @param string $routineName The name of the routine.
   *
   * @return null|string
   */
  private function methodName(string $routineName): ?string
  {
    if ($this->nameMangler!==null)
    {
      /** @var NameMangler $mangler */
      $mangler = $this->nameMangler;

      return $mangler::getMethodName($routineName);
    }

    return null;
  }

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Removes obsolete entries from the metadata of all stored routines.
   */
  private function removeObsoleteMetadata(): void
  {
    $routines = [];
    foreach ($this->sources as $source)
    {
      $routines[] = $source['routine_name'];
    }

    $this->stratumMetaData->purge($routines);
  }

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Gathers all replace pairs.
   *
   * @throws MySqlQueryErrorException
   * @throws \ReflectionException
   */
  private function replacePairs(): void
  {
    $this->replacePairsColumnTypes();
    $this->replacePairsConstants();
  }

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Selects schema, table, column names and the column type from MySQL and saves them as replace pairs.
   *
   * @throws MySqlQueryErrorException
   */
  private function replacePairsColumnTypes(): void
  {
    $columns = $this->dl->allTableColumns();

    $this->replacePairsColumnTypesExact($columns);
    $this->replacePairsColumnTypesMaxLength($columns);

    $this->io->text(sprintf('Selected %d column types for substitution', sizeof($columns)));
  }

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Gathers replace pairs based on exact column types.
   *
   * @param array[] $columns The details of all table columns.
   */
  private function replacePairsColumnTypesExact(array $columns): void
  {
    foreach ($columns as $column)
    {
      $key = mb_strtoupper('@'.$column['table_name'].'.'.$column['column_name'].'%type@');

      $value = $column['column_type'];

      // For VARCHAR and TEXT columns add character set.
      if ($column['character_set_name']!==null)
      {
        $value .= ' character set '.$column['character_set_name'];
      }

      $this->replacePairs[$key] = $value;
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Gathers replace pairs based on column types with maximum length.
   *
   * @param array[] $columns The details of all table columns.
   */
  private function replacePairsColumnTypesMaxLength(array $columns): void
  {
    foreach ($columns as $column)
    {
      $key = mb_strtoupper('@'.$column['table_name'].'.'.$column['column_name'].'%sort@');

      switch ($column['data_type'])
      {
        case 'char':
        case 'varchar':
          $max = $this->maxCharacters($column['character_set_name']);
          if ($max!==null)
          {
            $value = sprintf('%s(%d) character set %s',
                             $column['data_type'],
                             $max,
                             $column['character_set_name']);
          }
          else
          {
            $value = null;
          }
          break;

        case 'binary':
        case 'varbinary':
          $value = sprintf('%s(%d)', $column['data_type'], self::MAX_COLUMN_SIZE);
          break;

        default:
          $value = null;
      }

      if ($value!==null) $this->replacePairs[$key] = $value;
    }
  }

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Reads constants set the PHP configuration file and  adds them to the replace pairs.
   *
   * @throws \ReflectionException
   */
  private function replacePairsConstants(): void
  {
    if ($this->constantClassName===null) return;

    $reflection = new \ReflectionClass($this->constantClassName);

    $constants = $reflection->getConstants();
    foreach ($constants as $name => $value)
    {
      if (!is_numeric($value)) $value = "'".$value."'";

      $this->replacePairs['@'.$name.'@'] = $value;
    }

    $this->io->text(sprintf('Read %d constants for substitution from <fso>%s</fso>',
                            sizeof($constants),
                            OutputFormatter::escape($reflection->getFileName())));
  }

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Writes the metadata of all stored routines to the metadata file.
   *
   * @throws RuntimeException
   */
  private function writeStoredRoutineMetadata(): void
  {
    $this->stratumMetaData->writeMetadata($this->io);
  }

  //--------------------------------------------------------------------------------------------------------------------
}

//----------------------------------------------------------------------------------------------------------------------
